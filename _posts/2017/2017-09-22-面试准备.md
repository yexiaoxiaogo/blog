---
layout: post
title: "java面试"
date: 2017-09-22
tags: [面试]
commentIssueId: 12
---

## JVM

[JAVA面试题之JVM篇](http://www.jianshu.com/p/763ade0c7267)

[总结的JVM面试题](http://www.jianshu.com/p/54eb60cfa7bd)

## Java集合

[Java集合框架面试题](http://www.jianshu.com/p/6cec95e96e77)


## 线程&多线程
[Java线程面试题书目录](http://www.jianshu.com/p/6cec95e96e77)

1.多线程的实现原理是将一个进程分成多个线程，然后让他们并发异步执行，来提高运行效率。

2.创建线程有三种方式。

    * 继承Thread类，扩展线程（继承Thread类，覆盖run()方法；创建线程对象并用start()方法启动线程）
    * 实现Runnable接口
    * 通过Callable和Future创建线程
        * 1.创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并有返回值。
        * 2.创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
        * 3.使用FutreTask对象作为Thread对象的target创建并启动新线程。
        * 4.调用FuterTask对象的get()方法来获得子线程执行结束后的返回值。


3.创建线程的三种方式的对比

* 1.采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
* 2.使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。


4.我们都知道可以通过继承 Thread 类或者调用 Runnable 接口来实现线程，问题是，创建线程哪种方式更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口更好了。

5.在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。

    线程状态的转换关系：

![_20171103000021](https://user-images.githubusercontent.com/20008525/32336503-701bc15c-c02a-11e7-8ddf-cb266fab2bcc.png)

6.多线程编程时，需要了解的几个概念：
* 线程同步
* 线程间通信
* 线程死锁
* 线程控制：挂起、停止和恢复



## IO同步，异步

[阻塞 非阻塞 同步 异步 I/O 模型](http://blog.csdn.net/carol123456/article/details/51955264)

## Java String，StringBuffer和StringBuilder之间的区别

当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的
concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象，而 StringBuffer 的长度是可变的，调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

总结：

    String 长度大小不可变

    StringBuffer 和 StringBuilder 长度可变

    StringBuffer 线程安全 StringBuilder 线程不安全

    StringBuilder 速度快

## dubbo分布式服务框架，微服务

[Dubbo分布式服务框架入门](http://www.importnew.com/19732.html)

### Dubbo的架构模块

* provider 服务提供者
* container 服务运行容器
* consumer 服务消费者
* registry 注册中心
* monitor 监控中心


## 乐观锁和悲观锁的区别（事物）
* 悲观锁

    悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

    悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

    Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

* 乐观锁

    乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

    乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有以下2种方式：

    1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

    2.使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


## mybatis原理

## mybatis数据库连接

## SpringMVC 消息处理


![_20171106180814](https://user-images.githubusercontent.com/20008525/32436057-c59a68c2-c31d-11e7-89c8-e2caa25cf36c.png)


核心架构的具体流程：

    1.首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；
    2.DispatcherServlet——>HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；
    3.DispatcherServlet——>HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；
    4.HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；
    5.ModelAndView的逻辑视图名——> ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；
    6.View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；
    7.返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。

## spring boot启动原理

## spring IOC,DI&AOP作用&原理（spring的核心概念是IOC和AOP，降低耦合）

* IOC(inversion of control)控制反转
* DI(dependence injection)依赖注入
* AOP(aspect oriented programming)面向切面编程（java的动态代理）
    AOP是基于动态代理实现的。
* 动态代理的原理



## 数据库优化思想

* MySQL分页查询：limit关键字，和spring-data-jpa的使用

## 设计模式（这个问一下）

## redis做缓存

加入maven依赖，配置redis数据库信息

    在serviceimpl层实现缓存，实体类加上implements Serializable可序列化关键字


## JVM

什么是JVM？

    JVM是Java Virtual Machine（Java虚拟机）的缩写，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等组成。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。


JRE.JDK.JVM的关系


    JRE（Java Runtime Environment， Java运行环境）是Java平台，所有的程序都要在JRE下才能够运行。包括JVM和Java核心类库和支持文件。

    JDK（Java Development Kit，Java开发工具包）是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API ）。

    JVM（Java Virtual Machine， Java虚拟机）是JRE的一部分。JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java语言是跨平台运行的，不同的操作系统会有不同的JVM映射规则，使之与操作系统无关，完成跨平台性。



![jre jdk jvm](https://user-images.githubusercontent.com/20008525/31997011-15fb8afe-b9bd-11e7-9a09-68d22dc39ad4.png)



## 反射注解

什么是反射机制：

    Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。

    Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。

    换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。

Java反射机制提供的功能：

    Java反射机制提供如下功能：
    在运行时判断任意一个对象所属的类
    在运行时构造任意一个类的对象
    在运行时判段任意一个类所具有的成员变量和方法
    在运行时调用任一个对象的方法
    在运行时创建新类对象
    在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。


## Servlet

* servlet是运行在web服务器或者应用服务器上的程序，是作为来自web浏览器或者其他HTTP客户端的请求和HTTP服务器上的数据库或者应用程序之间的中间层。

    ![qq 20170927195516](https://user-images.githubusercontent.com/20008525/30912166-1db08156-a3be-11e7-8a8f-f31591d1e8b5.png)

* servlet的作用是收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。

servlet执行以下主要任务：

* 读取客户端（浏览器）发送的显式的数据。包括网页上HTML表单，或者也可以是来自applet或者自定义的HTTP客户端程序的表单。
* 读取客户端（浏览器）发送的隐式的HTTP请求数据。包括cookie、媒体类型和浏览器能理解的压缩格式等。
* 处理数据并生成结果。这个过程可能会需要访问数据库，执行RMI或CORBA调用，调用web服务器，或者直接计算得出对应的响应。
* 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML或XML）、二进制文件（GIF图像）、Excel等。
* 发送隐式的HTTP响应到客户端(浏览器)。这个包括告诉浏览器或者其他客户端被返回的文档类型，设置cookie和缓存参数，以及其他类似的任务。

## JSP& freemaker

JSP：后端模板，用于输出前端页面。后缀.jsp

    JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。

    JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。

    JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。
freemaker：后缀.ftl常用的模板引擎

## Java基本数据类型
* 1.byte 8位
* 2.short 16位
* 3.int 32位
* 4.long 64位
* 5.float 32位
* 6.double 64位
* 7.char 16位
* 8.boolean 1位

## 消息队列MQ

概述：

消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。


常用的消息队列：

目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。


应用场景：

消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。